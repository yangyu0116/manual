函数名: sbrk 
功 能: 改变数据段空间位置 
用 法: char *sbrk(int incr); 
程序例: 

#include <stdio.h> 
#include <alloc.h> 

int main(void) 
{ 
printf("Changing allocation with sbrk()\n"); 
printf("Before sbrk() call: %lu bytes free\n", 
(unsigned long) coreleft()); 
sbrk(1000); 
printf(" After sbrk() call: %lu bytes free\n", 
(unsigned long) coreleft()); 
return 0; 
} 



函数名: scanf 
功 能: 执行格式化输入 
用 法: int scanf(char *format[,argument,...]); 
程序例: 

#include <stdio.h> 
#include <conio.h> 

int main(void) 
{ 
char label[20]; 
char name[20]; 
int entries = 0; 
int loop, age; 
double salary; 

struct Entry_struct 
{ 
char name[20]; 
int age; 
float salary; 
} entry[20]; 

/* Input a label as a string of characters restricting to 20 characters */ 
printf("\n\nPlease enter a label for the chart: "); 
scanf("%20s", label); 
fflush(stdin); /* flush the input stream in case of bad input */ 

/* Input number of entries as an integer */ 
printf("How many entries will there be? (less than 20) "); 
scanf("%d", &entries); 
fflush(stdin); /* flush the input stream in case of bad input */ 

/* input a name restricting input to only letters upper or lower case */ 
for (loop=0;loop<entries;++loop) 
{ 
printf("Entry %d\n", loop); 
printf(" Name : "); 
scanf("%[A-Za-z]", entry[loop].name); 
fflush(stdin); /* flush the input stream in case of bad input */ 

/* input an age as an integer */ 
printf(" Age : "); 
scanf("%d", &entry[loop].age); 
fflush(stdin); /* flush the input stream in case of bad input */ 

/* input a salary as a float */ 
printf(" Salary : "); 
scanf("%f", &entry[loop].salary); 
fflush(stdin); /* flush the input stream in case of bad input */ 
} 

/* Input a name, age and salary as a string, integer, and double */ 
printf("\nPlease enter your name, age and salary\n"); 
scanf("%20s %d %lf", name, &age, &salary); 


/* Print out the data that was input */ 
printf("\n\nTable %s\n",label); 
printf("Compiled by %s age %d $%15.2lf\n", name, age, salary); 
printf("-----------------------------------------------------\n"); 
for (loop=0;loop<entries;++loop) 
printf("%4d | %-20s | %5d | %15.2lf\n", 
loop + 1, 
entry[loop].name, 
entry[loop].age, 
entry[loop].salary); 
printf("-----------------------------------------------------\n"); 
return 0; 
} 



函数名: searchpath 
功 能: 搜索DOS路径 
用 法: char *searchpath(char *filename); 
程序例: 

#include <stdio.h> 
#include <dir.h> 

int main(void) 
{ 
char *p; 

/* Looks for TLINK and returns a pointer 
to the path */ 
p = searchpath("TLINK.EXE"); 
printf("Search for TLINK.EXE : %s\n", p); 

/* Looks for non-existent file */ 
p = searchpath("NOTEXIST.FIL"); 
printf("Search for NOTEXIST.FIL : %s\n", p); 

return 0; 
} 



函数名: sector 
功 能: 画并填充椭圆扇区 
用 法: void far sector(int x, int y, int stangle, int endangle); 
程序例: 

#include <graphics.h> 
#include <stdlib.h> 
#include <stdio.h> 
#include <conio.h> 

int main(void) 
{ 
/* request auto detection */ 
int gdriver = DETECT, gmode, errorcode; 
int midx, midy, i; 
int stangle = 45, endangle = 135; 
int xrad = 100, yrad = 50; 

/* initialize graphics and local variables */ 
initgraph(&gdriver, &gmode, ""); 

/* read result of initialization */ 
errorcode = graphresult(); 
if (errorcode != grOk) /* an error occurred */ 
{ 
printf("Graphics error: %s\n", grapherrormsg(errorcode)); 
printf("Press any key to halt:"); 
getch(); 
exit(1); /* terminate with an error code */ 
} 

midx = getmaxx() / 2; 
midy = getmaxy() / 2; 

/* loop through the fill patterns */ 
for (i=EMPTY_FILL; i<USER_FILL; i++) 
{ 
/* set the fill style */ 
setfillstyle(i, getmaxcolor()); 

/* draw the sector slice */ 
sector(midx, midy, stangle, endangle, xrad, yrad); 

getch(); 
} 

/* clean up */ 
closegraph(); 
return 0; 
} 


函数名: segread 
功 能: 读段寄存器值 
用 法: void segread(struct SREGS *segtbl); 
程序例: 

#include <stdio.h> 
#include <dos.h> 

int main(void) 
{ 
struct SREGS segs; 

segread(&segs); 
printf("Current segment register settings\n\n"); 
printf("CS: %X DS: %X\n", segs.cs, segs.ds); 
printf("ES: %X SS: %X\n", segs.es, segs.ss); 

return 0; 
} 



函数名: setactivepage 
功 能: 设置图形输出活动页 
用 法: void far setactivepage(int pagenum); 
程序例: 

#include <graphics.h> 
#include <stdlib.h> 
#include <stdio.h> 
#include <conio.h> 

int main(void) 
{ 
/* select a driver and mode that supports */ 
/* multiple pages. */ 
int gdriver = EGA, gmode = EGAHI, errorcode; 
int x, y, ht; 

/* initialize graphics and local variables */ 
initgraph(&gdriver, &gmode, ""); 

/* read result of initialization */ 
errorcode = graphresult(); 
if (errorcode != grOk) /* an error occurred */ 
{ 
printf("Graphics error: %s\n", grapherrormsg(errorcode)); 
printf("Press any key to halt:"); 
getch(); 
exit(1); /* terminate with an error code */ 
} 

x = getmaxx() / 2; 
y = getmaxy() / 2; 
ht = textheight("W"); 

/* select the off screen page for drawing */ 
setactivepage(1); 

/* draw a line on page #1 */ 
line(0, 0, getmaxx(), getmaxy()); 

/* output a message on page #1 */ 
settextjustify(CENTER_TEXT, CENTER_TEXT); 
outtextxy(x, y, "This is page #1:"); 
outtextxy(x, y+ht, "Press any key to halt:"); 

/* select drawing to page #0 */ 
setactivepage(0); 

/* output a message on page #0 */ 
outtextxy(x, y, "This is page #0."); 
outtextxy(x, y+ht, "Press any key to view page #1:"); 
getch(); 

/* select page #1 as the visible page */ 
setvisualpage(1); 

/* clean up */ 
getch(); 
closegraph(); 
return 0; 
} 



函数名: setallpallette 
功 能: 按指定方式改变所有的调色板颜色 
用 法: void far setallpallette(struct palette, far *pallette); 
程序例: 

#include <graphics.h> 
#include <stdlib.h> 
#include <stdio.h> 
#include <conio.h> 

int main(void) 
{ 
/* request auto detection */ 
int gdriver = DETECT, gmode, errorcode; 
struct palettetype pal; 
int color, maxcolor, ht; 
int y = 10; 
char msg[80]; 

/* initialize graphics and local variables */ 
initgraph(&gdriver, &gmode, ""); 

/* read result of initialization */ 
errorcode = graphresult(); 
if (errorcode != grOk) /* an error occurred */ 
{ 
printf("Graphics error: %s\n", grapherrormsg(errorcode)); 
printf("Press any key to halt:"); 
getch(); 
exit(1); /* terminate with an error code */ 
} 

maxcolor = getmaxcolor(); 
ht = 2 * textheight("W"); 

/* grab a copy of the palette */ 
getpalette(&pal); 

/* display the default palette colors */ 
for (color=1; color<=maxcolor; color++) 
{ 
setcolor(color); 
sprintf(msg, "Color: %d", color); 
outtextxy(1, y, msg); 
y += ht; 
} 

/* wait for a key */ 
getch(); 

/* black out the colors one by one */ 
for (color=1; color<=maxcolor; color++) 
{ 
setpalette(color, BLACK); 
getch(); 
} 

/* restore the palette colors */ 
setallpalette(&pal); 

/* clean up */ 
getch(); 
closegraph(); 
return 0; 
} 



函数名: setaspectratio 
功 能: 设置图形纵横比 
用 法: void far setaspectratio(int xasp, int yasp); 
程序例: 

#include <graphics.h> 
#include <stdlib.h> 
#include <stdio.h> 
#include <conio.h> 

int main(void) 
{ 
/* request auto detection */ 
int gdriver = DETECT, gmode, errorcode; 
int xasp, yasp, midx, midy; 

/* initialize graphics and local variables */ 
initgraph(&gdriver, &gmode, ""); 

/* read result of initialization */ 
errorcode = graphresult(); 
if (errorcode != grOk) /* an error occurred */ 
{ 
printf("Graphics error: %s\n", grapherrormsg(errorcode)); 
printf("Press any key to halt:"); 
getch(); 
exit(1); /* terminate with an error code */ 
} 

midx = getmaxx() / 2; 
midy = getmaxy() / 2; 
setcolor(getmaxcolor()); 

/* get current aspect ratio settings */ 
getaspectratio(&xasp, &yasp); 

/* draw normal circle */ 
circle(midx, midy, 100); 
getch(); 

/* claer the screen */ 
cleardevice(); 

/* adjust the aspect for a wide circle */ 
setaspectratio(xasp/2, yasp); 
circle(midx, midy, 100); 
getch(); 

/* adjust the aspect for a narrow circle */ 
cleardevice(); 
setaspectratio(xasp, yasp/2); 
circle(midx, midy, 100); 

/* clean up */ 
getch(); 
closegraph(); 
return 0; 
} 



函数名: setbkcolor 
功 能: 用调色板设置当前背景颜色 
用 法: void far setbkcolor(int color); 
程序例: 

#include <graphics.h> 
#include <stdlib.h> 
#include <stdio.h> 
#include <conio.h> 

int main(void) 
{ 
/* select a driver and mode that supports */ 
/* multiple background colors. */ 
int gdriver = EGA, gmode = EGAHI, errorcode; 
int bkcol, maxcolor, x, y; 
char msg[80]; 

/* initialize graphics and local variables */ 
initgraph(&gdriver, &gmode, ""); 

/* read result of initialization */ 
errorcode = graphresult(); 
if (errorcode != grOk) /* an error occurred */ 
{ 
printf("Graphics error: %s\n", grapherrormsg(errorcode)); 
printf("Press any key to halt:"); 
getch(); 
exit(1); /* terminate with an error code */ 
} 

/* maximum color index supported */ 
maxcolor = getmaxcolor(); 

/* for centering text messages */ 
settextjustify(CENTER_TEXT, CENTER_TEXT); 
x = getmaxx() / 2; 
y = getmaxy() / 2; 

/* loop through the available colors */ 
for (bkcol=0; bkcol<=maxcolor; bkcol++) 
{ 
/* clear the screen */ 
cleardevice(); 

/* select a new background color */ 
setbkcolor(bkcol); 

/* output a messsage */ 
if (bkcol == WHITE) 
setcolor(EGA_BLUE); 
sprintf(msg, "Background color: %d", bkcol); 
outtextxy(x, y, msg); 
getch(); 
} 

/* clean up */ 
closegraph(); 
return 0; 
} 



函数名: setblock 
功 能: 修改先前已分配的DOS存储段大小 
用 法: int setblock(int seg, int newsize); 
程序例: 

#include <dos.h> 
#include <alloc.h> 
#include <stdio.h> 
#include <stdlib.h> 

int main(void) 
{ 
unsigned int size, segp; 
int stat; 

size = 64; /* (64 x 16) = 1024 bytes */ 
stat = allocmem(size, &segp); 
if (stat == -1) 
printf("Allocated memory at segment: %X\n", segp); 
else 
{ 
printf("Failed: maximum number of paragraphs available is %d\n", 
stat); 
exit(1); 
} 

stat = setblock(segp, size * 2); 
if (stat == -1) 
printf("Expanded memory block at segment: %X\n", segp); 
else 
printf("Failed: maximum number of paragraphs available is %d\n", 
stat); 

freemem(segp); <b
